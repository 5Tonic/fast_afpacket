package fastafpacket

import (
	"encoding/binary"
	"fmt"
	"net"
	"time"

	"github.com/mdlayher/socket"
	"golang.org/x/net/bpf"
	"golang.org/x/sys/unix"
)

const (
	// SocketOptTimestamping is an alias for unix.SO_TIMESTAMPING
	SocketOptTimestamping = 0x25

	// MsgErrQueue is an alias for unix.MSG_ERRQUEUE
	MsgErrQueue = 0x2000
)

var (
	unixEpoch = time.Date(1970, time.January, 1, 0, 0, 0, 0, time.UTC)
)

// Addr is the Layer 1 address
type Addr struct {
	HardwareAddr net.HardwareAddr
}

// Network returns the network name
func (a *Addr) Network() string {
	return "packet"
}

// String returns the Layer 1 string address
func (a *Addr) String() string {
	return a.HardwareAddr.String()
}

// Config
type Config struct {
	// DualConn creates separate send and recv connections to minimize contention
	// on a single file descriptor. Enable this option if you're sending packets
	// at a high rate. Calling methods on Conn will transparently use the correct
	// underlying socket.
	DualConn bool

	// Filter will be applied to the socket before bind is called to ensure
	// no packets will come through before the connection is opened.
	Filter []bpf.RawInstruction
}

// Conn implements net.PacketConn and uses AF_PACKET under the hood
type Conn struct {
	iface    *net.Interface
	addr     net.Addr
	protocol int
	s        *socket.Conn
	r        *socket.Conn
}

// Close implements net.PacketConn Close
func (c *Conn) Close() error {
	if err := c.s.Close(); err != nil {
		return err
	}
	if err := c.r.Close(); err != nil {
		return err
	}

	return nil
}

// LocalAddr implements net.PacketConn LocalAddr
func (c *Conn) LocalAddr() net.Addr {
	return c.addr
}

// RecvTxTimestamps blocks and listens on the underlying socket's error queue
// for outgoing Tx timestamp information and returns the original packet plus
// the timestamp information.
func (c *Conn) RecvTxTimestamps(b []byte) (int, net.Addr, SocketTimestamps, error) {
	return c.recvTimestamps(b, MsgErrQueue)
}

// RecvRxTimestamps blocks and listens on the underlying socket's Rx queue for
// incoming packets while also returning the Rx timestamps for that packet. This
// can be used instead of ReadFrom to get SocketTimestamps returned along with
// the packet data.
func (c *Conn) RecvRxTimestamps(b []byte) (int, net.Addr, SocketTimestamps, error) {
	return c.recvTimestamps(b, 0)
}

// ReadFrom implements net.PacketConn ReadFrom
func (c *Conn) ReadFrom(b []byte) (int, net.Addr, error) {
	return c.readFrom(b)
}

// WriteTo implements net.PacketConn WriteTo
func (c *Conn) WriteTo(b []byte, addr net.Addr) (int, error) {
	return c.writeTo(b, addr)
}

// SetDeadline implements net.PacketConn SetDeadline
func (c *Conn) SetDeadline(t time.Time) error {
	if err := c.s.SetDeadline(t); err != nil {
		return err
	}
	if err := c.r.SetDeadline(t); err != nil {
		return err
	}

	return nil
}

// SetReadDeadline implements net.PacketConn SetReadDeadline
func (c *Conn) SetReadDeadline(t time.Time) error {
	if err := c.r.SetReadDeadline(t); err != nil {
		return err
	}

	return nil
}

// SetWriteDeadline implements net.PacketConn Close
func (c *Conn) SetWriteDeadline(t time.Time) error {
	if err := c.s.SetWriteDeadline(t); err != nil {
		return err
	}

	return nil
}

// SetBPF applies the BPF program filter to the socket
func (c *Conn) SetBPF(filter []bpf.RawInstruction) error {
	return c.setBPF(filter)
}

// Stats are the statistics obtained from the kernel.
type Stats struct {
	// Packets are the total number of packets received
	Packets uint32

	// Drops are the number of packets dropped
	Drops uint32

	// FreezeQueueCount is the total number of times that a receive queue is
	// frozen. May be zero if the kernel is not new enough to support TPACKET_V3
	FreezeQueueCount uint32
}

// Stats reads statistics from the kernel for the connection. Calling this resets
// the kernel counters to 0 so you must keep running totals in the calling code.
func (c *Conn) Stats() (*Stats, error) {
	return c.stats()
}

// SocketTimestamps represet the timestamps generated by the NIC (Hardware) and
// the Kernel (Software) that is parse from the control message.
type SocketTimestamps struct {
	Software time.Time
	Hardware time.Time
}

// ParseSocketTimestamps parses the timestamp information from the control message
// it will also convert Unix epoch times to Go's zero value time to be able
// to use .IsZero() on timestamps that have a default value or are not available.
// https://www.kernel.org/doc/html/v5.14/networking/timestamping.html#scm-timestamping-records
func ParseSocketTimestamps(msg unix.SocketControlMessage) (SocketTimestamps, error) {
	var ts SocketTimestamps

	if msg.Header.Level != unix.SOL_SOCKET && msg.Header.Type != SocketOptTimestamping {
		return ts, fmt.Errorf("no timestamp control messages")
	}

	ts.Software = time.Unix(int64(binary.LittleEndian.Uint64(msg.Data[0:])), int64(binary.LittleEndian.Uint64(msg.Data[8:])))
	ts.Hardware = time.Unix(int64(binary.LittleEndian.Uint64(msg.Data[32:])), int64(binary.LittleEndian.Uint64(msg.Data[40:])))

	// convert Unix epoch to Go's zero value of time

	if ts.Software.Equal(unixEpoch) {
		ts.Software = time.Time{}
	}

	if ts.Hardware.Equal(unixEpoch) {
		ts.Hardware = time.Time{}
	}

	return ts, nil
}
